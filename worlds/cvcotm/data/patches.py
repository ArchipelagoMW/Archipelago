remote_textbox_shower = [
    # Pops up the textbox(s) of whatever textbox IDs is written at 0x02025300 and 0x02025302 and increments the current
    # received item index at 0x020253D0 if a number to increment it by is written at 0x02025304. Also plays the sound
    # effect of the ID written at 0x02025306, if one is written there. This will NOT give any items on its own; the item
    # has to be written by the client into the inventory alongside writing the above-mentioned things.

    # Make sure we didn't hit the lucky one frame before room transitioning wherein Nathan is on top of the room
    # transition tile.
    0x0C, 0x88,  # ldrh r4, [r1]
    0x80, 0x20,  # movs r0, #0x80
    0x20, 0x40,  # ands r0, r4
    0x00, 0x28,  # cmp  r0, #0
    0x2F, 0xD1,  # bne  0x87FFF8A
    0x11, 0xB4,  # push r0, r4
    # Check the cutscene value to make sure we are not in a cutscene; forcing a textbox while there's already another
    # textbox on-screen messes things up.
    0x1E, 0x4A,  # ldr  r2, =0x2026000
    0x13, 0x78,  # ldrb r3, [r2]
    0x00, 0x2B,  # cmp  r0, #0
    0x29, 0xD1,  # bne  0x87FFF88
    # Check our "delay" timer buffer for a non-zero. If it is, decrement it by one and skip straight to the return part
    # of this code, as we may have received an item on a frame wherein it's "unsafe" to pop the item textbox.
    0x16, 0x4A,  # ldr  r2, =0x2025300
    0x13, 0x89,  # ldrh r3, [r2, #8]
    0x00, 0x2B,  # cmp  r0, #0
    0x02, 0xD0,  # beq  0x87FFF42
    0x01, 0x3B,  # subs r3, #1
    0x13, 0x81,  # strh r3, [r2, #8]
    0x22, 0xE0,  # beq  0x87FFF88
    # Check our first custom "textbox ID" buffers for a non-zero number.
    0x10, 0x88,  # ldrh r0, [r2]
    0x00, 0x28,  # cmp  r0, #0
    0x12, 0xD0,  # beq  0x87FFF6E
    # Increase the "received item index" by the specified number in our "item index amount to increase" buffer.
    0x93, 0x88,  # ldrh r3, [r2, #4]
    0xD0, 0x32,  # adds r2, #0xD0
    0x11, 0x88,  # ldrh r1, [r2]
    0xC9, 0x18,  # adds r1, r1, r3
    0x11, 0x80,  # strh r1, [r2]
    # Check our second custom "textbox ID" buffers for a non-zero number.
    0xD0, 0x3A,  # subs r2, #0xD0
    0x51, 0x88,  # ldrh r1, [r2, #2]
    0x00, 0x29,  # cmp  r1, #0
    0x01, 0xD0,  # beq  0x87FFF5E
    # If we have a second textbox ID, run the "display two textboxes" function.
    # Otherwise, run the "display one textbox" function.
    0x0E, 0x4A,  # ldr  r2, =0x805F104
    0x00, 0xE0,  # b    0x87FFF60
    0x0E, 0x4A,  # ldr  r2, =0x805F0C8
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # adds r3, #5
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    0x09, 0x48,  # ldr  r0, =0x2025300
    0x02, 0x21,  # movs r1, #2
    0x01, 0x81,  # strh r1, [r0, #8]
    # Check our "sound effect ID" buffer and run the "play sound" function if it's a non-zero number.
    0x08, 0x48,  # ldr  r0, =0x2025300
    0xC0, 0x88,  # ldrh r0, [r0, #6]
    0x00, 0x28,  # cmp  r0, #0
    0x04, 0xD0,  # beq  0x87FFF7E
    0x0B, 0x4A,  # ldr  r2, =0x8005E80
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # adds r3, #5
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    # Clear all our buffers and return to the "check for Nathan being in a room transition" function we've hooked into.
    0x03, 0x48,  # ldr  r0, =0x2025300
    0x00, 0x21,  # movs r1, #0
    0x01, 0x60,  # str  r1, [r0]
    0x41, 0x60,  # str  r1, [r0, #4]
    0x11, 0xBC,  # pop  r0, r4
    0x04, 0x4A,  # ldr  r2, =0x8007D68
    0x00, 0x28,  # cmp  r0, #0
    0x97, 0x46,  # mov  r15, r2
    # LDR number pool
    0x00, 0x53, 0x02, 0x02,
    0x04, 0xF1, 0x05, 0x08,
    0xC8, 0xF0, 0x05, 0x08,
    0x68, 0x7D, 0x00, 0x08,
    0x90, 0x1E, 0x02, 0x02,
    0x80, 0x5E, 0x00, 0x08,
    0x00, 0x60, 0x02, 0x02
]

transition_textbox_delayer = [
    # Sets the remote item textbox delay timer whenever the player screen transitions to ensure the item textbox won't
    # pop during said transition.
    0x40, 0x78,  # ldrb r0, [r0, #1]
    0x28, 0x70,  # strb r0, [r5]
    0xF8, 0x6D,  # ldr  r0, [r7, #0x5C]
    0x20, 0x18,  # adds r0, r4, r0
    0x02, 0x4A,  # ldr  r2, =0x2025300
    0x10, 0x23,  # movs r3, #0x10
    0x13, 0x80,  # strh r3, [r2]
    0x02, 0x4A,  # ldr  r2, =0x806CE1C
    0x97, 0x46,  # mov  r15, r2
    0x00, 0x00,
    # LDR number pool
    0x08, 0x53, 0x02, 0x02,
    0x1C, 0xCE, 0x06, 0x08,
]

map_sfx_preventer = [
    # Prevents the Magic Item pickup sound from playing if the Magic Item being picked up is the Map specifically.
    # In these cases, the appropriate sound is played by the written remote textbox instead.
    0x70, 0x68,  # ldr  r0, [r6, #4]
    0xC0, 0x88,  # ldrh r0, [r0, #6]
    0x05, 0x21,  # mov  r1, #5
    0x88, 0x42,  # cmp  r0, r1
    0x06, 0xD0,  # beq  0x87FFE68
    0xDA, 0x20,  # movs r0, #0xDA
    0x40, 0x00,  # lsls r0, r0, #1
    0x03, 0x4A,  # ldr  r2, =0x8005E80
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # adds r3, #5
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    0x01, 0x48,  # ldr  r0, =0x8095BEC
    0x87, 0x46,  # mov  r15, r0
    # LDR number pool
    0x80, 0x5E, 0x00, 0x08,
    0xEC, 0x5B, 0x09, 0x08,
]

missing_char_data = {
    # The data for all missing ASCII characters from the game's dialogue textbox font.

    # Each character consists of 8 bytes, with each byte representing one row of pixels in the character. The bytes are
    # arranged from top to bottom row going from left to right.

    # Each bit within each byte represents the following pixels within that row:
    # 8- = -+------
    # 4- = +-------
    # 2- = ---+----
    # 1- = --+-----
    # -8 = -----+--
    # -4 = ----+---
    # -2 = -------+
    # -1 = ------+-
    0x396C54: [0x00, 0x9C, 0x9C, 0x18, 0x84, 0x00, 0x00, 0x00],  # "
    0x396C5C: [0x00, 0x18, 0xBD, 0x18, 0x18, 0x18, 0xBD, 0x18],  # #
    0x396C64: [0x00, 0x0C, 0x2D, 0x0C, 0x21, 0x00, 0x00, 0x00],  # *
    0x396C6C: [0x00, 0x20, 0x3C, 0xA0, 0x34, 0x28, 0xB4, 0x20],  # $
    0x396C74: [0x00, 0x34, 0x88, 0x80, 0xB4, 0x88, 0x88, 0x34],  # 6
    0x396C7C: [0x00, 0xBC, 0x88, 0x04, 0x04, 0x20, 0x20, 0x20],  # 7
    0x396CBC: [0x00, 0x34, 0x88, 0x88, 0x3C, 0x08, 0x88, 0x34],  # 9
    0x396CC4: [0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0xC0],  # :
    0x396CCC: [0x00, 0xC0, 0xC0, 0x00, 0xC0, 0xC0, 0x80, 0x40],  # ;
    0x396D0C: [0x00, 0x00, 0x09, 0x24, 0x90, 0x24, 0x09, 0x00],  # <
    0x396D14: [0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0xFD, 0x00],  # =
    0x396D1C: [0x00, 0x00, 0xC0, 0x30, 0x0C, 0x30, 0xC0, 0x00],  # >
    0x396D54: [0x00, 0x34, 0x88, 0xAC, 0xA8, 0xAC, 0x80, 0x34],  # @
    0x396D5C: [0x00, 0x34, 0x88, 0x88, 0xA8, 0x8C, 0x88, 0x35],  # Q
    0x396D64: [0x00, 0x40, 0x80, 0x10, 0x20, 0x04, 0x08, 0x01],  # \
    0x396D6C: [0x00, 0x20, 0x14, 0x88, 0x00, 0x00, 0x00, 0x00],  # ^
    0x396D9C: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD],  # _
    0x396DA4: [0x00, 0x90, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00],  # `
    0x396DAC: [0x00, 0x08, 0x04, 0x04, 0x20, 0x04, 0x04, 0x08],  # {
    0x396DB4: [0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20],  # |
    0x396DBC: [0x00, 0x80, 0x10, 0x10, 0x20, 0x10, 0x10, 0x80],  # }
    0x396DF4: [0x00, 0x00, 0x00, 0x90, 0x61, 0x0C, 0x00, 0x00],  # ~
}
