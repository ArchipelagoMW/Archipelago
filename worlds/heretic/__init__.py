# APWorld for Heretic
#
# This file is automatically generated by ap_gen_tool version 2.0.
# For more information: https://github.com/ArchipelagoDoom/ap_gen_tool

import typing

import BaseClasses as AP  # noqa: N814
from worlds._id1common import id1CommonWorld
from worlds.AutoWorld import WebWorld

from .options import HereticOptionGroups, HereticOptions

game_name = "Heretic"


class HereticLocation(AP.Location):
    game: str = game_name


class HereticItem(AP.Item):
    game: str = game_name


class HereticWeb(WebWorld):
    option_groups = HereticOptionGroups
    rich_text_options_doc = True
    bug_report_page = "https://github.com/ArchipelagoDoom/APDoom/issues"
    theme = "dirt"
    tutorials = [AP.Tutorial(
        "Multiworld Setup Guide",
        f"A guide to setting up the {game_name} randomizer connected to an Archipelago Multiworld.",
        "English",
        "setup_en.md",
        "setup/en",
        ["Daivuk", "Kaito Sinclaire"]
    )]


class HereticWorld(id1CommonWorld, import_data=(__name__, "heretic.data.json")):
    """
    Heretic is a dark fantasy first-person shooter video game released in December 1994.
    It was developed by Raven Software.
    """
    game = game_name
    options_dataclass = HereticOptions
    options: HereticOptions  # type: ignore
    web = HereticWeb()
    required_client_version = (0, 6, 3)  # APDoom version 2.0.0

    extra_connection_requirements = {
        "deathlogic": lambda self: self.options.allow_death_logic.value == 1,
        "trick_basic": lambda self: self.options.trick_difficulty.value >= 1,
        "trick_pro": lambda self: self.options.trick_difficulty.value >= 2,
        "trick_extreme": lambda self: self.options.trick_difficulty.value >= 3,
    }

    def create_item(self, name: str) -> HereticItem:
        item_id = self.item_name_to_id[name]
        item_data = self.item_table[item_id]
        classification = item_data.classification

        return HereticItem(name, classification, item_id, self.player)

    def generate_early(self) -> None:
        self.init_episodes()

        ######## Custom code for this world begins here ########
        # For Solo Episode 1, place the Yellow Key for E1M1 early.
        # Gives the generator five potential placements (plus the forced key) instead of only two.
        if self.solo_episode(1):
            self.multiworld.early_items[self.player]["The Docks (E1M1) - Yellow key"] = 1
        ######## Custom code for this world ends here ########

        ######## Custom code for world option 'Custom Ammo Capacity' begins here ########
        if (
            self.options.max_ammo_wand_crystals.value < self.options.max_ammo_wand_crystals.default
            or self.options.max_ammo_ethereal_arrows.value < self.options.max_ammo_ethereal_arrows.default
            or self.options.max_ammo_claw_orbs.value < self.options.max_ammo_claw_orbs.default
            or self.options.max_ammo_runes.value < self.options.max_ammo_runes.default
            or self.options.max_ammo_flame_orbs.value < self.options.max_ammo_flame_orbs.default
            or self.options.max_ammo_mace_spheres.value < self.options.max_ammo_mace_spheres.default
        ):
            self.warning("Some starting ammo capacity options are set below their default values.\n"
                         "This may make games significantly harder than intended; you have been warned.")
        ######## Custom code for world option 'Custom Ammo Capacity' ends here ########

    def create_regions(self) -> None:
        self.construct_regions()
        self.make_regions(location_type=HereticLocation)

    def set_rules(self) -> None:
        self.make_rules()

    def create_items(self) -> None:
        self.place_level_complete_items(item_type=HereticItem)

        itempool = self.construct_base_item_pool()
        location_count = len(self.multiworld.get_unfilled_locations(self.player))
        def pop_from_pool(name: str) -> str | None:
            return itempool.pop(itempool.index(name)) if name in itempool else None

        # Give starting levels immediately
        map_items = [pop_from_pool(map_name) for map_name in self.starting_levels]
        [self.multiworld.push_precollected(self.create_item(n)) for n in map_items if n is not None]

        ######## Custom code for world option 'Start with Maps' begins here ########
        map_opt = self.options.start_with_map_scrolls
        if map_opt.value:
            map_items = [pop_from_pool(i.name) for i in self.matching_items(doom_type=map_opt.doom_type).values()]
            [self.multiworld.push_precollected(self.create_item(n)) for n in map_items if n is not None]
        ######## Custom code for world option 'Start with Maps' ends here ########

        ######## Custom code for world option 'Capacity Upgrades' begins here ########
        split_opt = self.options.split_bag_of_holding
        split_items = list(self.matching_items(doom_type=split_opt.split_doom_types).values())
        combined_items = list(self.matching_items(doom_type=split_opt.doom_type).values())

        # Remove stray capacity upgrades of all types from the pool
        item_names = [i.name for i in split_items] + [i.name for i in combined_items]
        itempool = [n for n in itempool if n not in item_names]

        # Insert requested types and count of capacity upgrades
        if split_opt.value:
            itempool += [i.name for i in split_items for _ in range(self.options.bag_of_holding_count.value)]
        else:
            itempool += [i.name for i in combined_items for _ in range(self.options.bag_of_holding_count.value)]
        ######## Custom code for world option 'Capacity Upgrades' ends here ########

        # Fill remainder with filler, and submit
        self.fill_item_pool(itempool, location_count)
        self.multiworld.itempool.extend(self.create_item(item) for item in itempool)

    def fill_slot_data(self) -> dict[str, typing.Any]:
        slot_data = super().fill_slot_data()

        ######## Custom code for world option 'Custom Ammo Capacity' begins here ########
        slot_data["ammo_start"] = [
            self.options.max_ammo_wand_crystals.value,
            self.options.max_ammo_ethereal_arrows.value,
            self.options.max_ammo_claw_orbs.value,
            self.options.max_ammo_runes.value,
            self.options.max_ammo_flame_orbs.value,
            self.options.max_ammo_mace_spheres.value,
        ]
        slot_data["ammo_add"] = [
            self.options.added_ammo_wand_crystals.value,
            self.options.added_ammo_ethereal_arrows.value,
            self.options.added_ammo_claw_orbs.value,
            self.options.added_ammo_runes.value,
            self.options.added_ammo_flame_orbs.value,
            self.options.added_ammo_mace_spheres.value,
        ]
        ######## Custom code for world option 'Custom Ammo Capacity' ends here ########

        return slot_data

