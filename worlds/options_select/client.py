from kvui import (MDApp, ScrollBox, MainLayout, ContainerLayout, dp, Widget, MDBoxLayout, TooltipLabel, ToolTip,
                  MDLabel, ToggleButton)
from kivy.graphics import Rectangle, Color
from kivymd.uix.anchorlayout import MDAnchorLayout
from kivymd.uix.expansionpanel import MDExpansionPanel, MDExpansionPanelContent, MDExpansionPanelHeader
from kivymd.uix.list import MDListItem, MDListItemTrailingIcon
from kivymd.uix.slider import MDSlider
from kivymd.uix.menu import MDDropdownMenu
from kivymd.uix.button import MDButton, MDButtonText, MDIconButton
from kivymd.uix.textfield import MDTextField
from kivy.metrics import sp
from textwrap import dedent
import Utils
import typing
import webbrowser
from urllib.parse import urlparse
from worlds.AutoWorld import AutoWorldRegister, World
from Options import (Option, Toggle, TextChoice, Choice, FreeText, NamedRange, Range, OptionSet, OptionList, OptionDict,
                     Removed, Visibility, VerifyKeys, PlandoTexts, PlandoConnections, ItemLinks)

from .core import save_filename, FixedTooltipLabel

def validate_url(x):
    try:
        result = urlparse(x)
        return all([result.scheme, result.netloc])
    except AttributeError:
        return False


def filter_tooltip(tooltip):
    if tooltip is None:
        tooltip = "No tooltip available"
    return dedent(tooltip).replace("\n", "<br>").replace("&", "&amp;").replace("[", "&bl;").replace("]", "&br;")


def option_can_be_randomized(option: typing.Type[Option]):
    # most options can be randomized, so we should just check for those that cannot
    if any(issubclass(option, option_type) for option_type in (VerifyKeys, Removed, PlandoTexts,
                                                               PlandoConnections, ItemLinks)):
        return False
    elif issubclass(option, FreeText) and not issubclass(option, TextChoice):
        return False
    return True

def check_random(value: typing.Any):
    if not isinstance(value, str):
        return value # cannot be random if evaluated
    if value.startswith("random-"):
        return "random"
    return value

class YamlCreator(MDApp):
    container: ContainerLayout
    main_layout: MainLayout
    scrollbox: ScrollBox
    main_panel: MainLayout
    player_options: MainLayout
    option_layout: MainLayout
    name_input: MDTextField
    game_label: MDLabel
    current_game: str
    options: typing.Dict[str, typing.Any]

    def export_options(self, _: Widget):
        if self.name_input.text and self.current_game:
            file_name = save_filename("Export Options File As...", [("YAML", ["*.yaml"])],
                                            Utils.get_file_safe_name(f"{self.name_input.text}.yaml"))
            options = {
                "name": self.name_input.text,
                "description": f"YAML generated by Archipelago {Utils.__version__}.",
                "game": self.current_game,
                self.current_game: {k: check_random(v) for k, v in self.options.items()}
            }
            with open(file_name, 'w') as f:
                f.write(Utils.dump(options, sort_keys=False))
                f.close()

    def create_range(self, option: typing.Type[Range], name: str):
        def update_text(slider, touch):
            slider.text.text = f"{slider.value:.0f}"
            self.options[name] = int(slider.value)
            return

        box = MDBoxLayout(spacing=15, orientation="horizontal")
        slider = MDSlider(min=option.range_start, max=option.range_end, value=option.default, step=1)
        number_label = MDLabel(text=str(option.default))
        slider.text = number_label
        slider.bind(on_touch_move=update_text)
        box.add_widget(slider)
        box.slider = slider
        box.add_widget(number_label)
        self.options[name] = option.default
        return box

    def create_named_range(self, option: typing.Type[NamedRange], name: str):
        def set_to_custom(slider, touch):
            slider.dropdown.select("Custom")
            self.options[name] = slider.value

        def set_value(button):
            slider_box.slider.dropdown.select(button.text)
            self.options[name] = button.text.lower()
            slider_box.slider.value = option.special_range_names[button.text.lower()]
            slider_box.slider.text.text = f"{slider_box.slider.value:.0f}"

        def open(button):
            # for some reason this fixes an issue causing some to not open
            slider_box.slider.dropdown.open()

        box = MDBoxLayout(orientation="vertical", spacing=5)
        slider_box = self.create_range(option, name)
        slider_box.slider.bind(on_touch_move=set_to_custom)
        items = [
            {
                "text": choice.title(),
                "on_release": set_value
            }
            for choice in option.special_range_names
        ]
        slider_box.slider.dropdown = MDDropdownMenu(caller=slider_box.slider, items=items)
        if option.default in option.special_range_names.values():
            default = list(option.special_range_names.keys())[list(option.special_range_names.values())
                                                              .index(option.default)]
        else:
            default = "Custom"
        main_button = MDButton(MDButtonText(default.title()))
        main_button.bind(on_release=open)
        slider_box.slider.dropdown.bind(on_select=lambda instance, x: setattr(main_button, '_text', x))
        box.add_widget(main_button)
        box.add_widget(slider_box)
        self.options[name] = option.default
        return box

    def create_free_text(self, option: typing.Union[typing.Type[FreeText], typing.Type[TextChoice]], name: str):
        text = MDTextField(multiline=False, font_size=sp(11),
                         text=option.default if isinstance(option.default, str) else "")
        def set_value(instance):
            self.options[name] = instance.text

        text.bind(on_text_validate=set_value)
        return text

    def create_choice(self, option: typing.Type[Choice], name: str):
        def set_value(text, value):
            dropdown.select(text)
            self.options[name] = value

        def open(button):
            # for some reason this fixes an issue causing some to not open
            dropdown.open()

        default_random = option.default == "random"
        default = option.default if not default_random else list(option.options.values())[0]
        main_button = MDButton(MDButtonText(option.get_option_name(default)))
        main_button.bind(on_release=open)

        items = [
            {
                "text": option.get_option_name(choice),
                "on_release": lambda val=choice: set_value(option.get_option_name(val), option.name_lookup[val])
            }
            for choice in option.name_lookup
        ]
        dropdown = MDDropdownMenu(caller=main_button, items=items)
        self.options[name] = option.name_lookup[option.default] if not default_random else option.default
        dropdown.bind(on_select=lambda instance, x: setattr(main_button, '_text', x))
        return main_button

    def create_text_choice(self, option: typing.Type[TextChoice], name: str):
        choice_button = self.create_choice(option, name)
        text = self.create_free_text(option, name)
        box = MDBoxLayout(orientation="vertical")
        box.add_widget(choice_button)
        box.add_widget(text)

        def set_value(instance):
            setattr(choice_button, "text", "Custom")
            self.options[name] = instance.text

        text.bind(on_text_validate=set_value)
        return box

    def create_toggle(self, option: typing.Type[Toggle], name: str) -> Widget:
        def set_value(instance, value):
            if value:
                instance.icon = "checkbox-blank-outline"
            else:
                instance.icon = "checkbox-outline"
            self.options[name] = bool(value)
        def_icon = "checkbox-outline" if option.default else "checkbox-blank-outline"
        checkbox = MDIconButton(icon=def_icon)
        checkbox.bind(on_release=set_value)
        self.options[name]=bool(option.default)
        return checkbox


    def create_option(self, option: typing.Type[Option], name: str) -> Widget:
        option_base = MDBoxLayout(orientation="vertical", )
        #with option_base.canvas:
        #    Color(0.2, 0.2, 0.2, 1)
        #    option_base.bg_rect = Rectangle(size=option_base.size, pos=option_base.pos)

        #def redraw(self, args):
        #    self.bg_rect.size = self.size
        #    self.bg_rect.pos = self.pos

        #option_base.bind(pos=redraw, size=redraw)

        tooltip = filter_tooltip(option.__doc__)
        option_label = FixedTooltipLabel(text=f"[ref=0|{tooltip}]{getattr(option, 'display_name', name)}")
        label_box = MDBoxLayout(orientation="horizontal")
        label_anchor = MDAnchorLayout(anchor_x="right", anchor_y="center")
        label_anchor.add_widget(option_label)
        label_box.add_widget(label_anchor)

        option_base.add_widget(label_box)
        if issubclass(option, NamedRange):
            option_base.add_widget(self.create_named_range(option, name))
        elif issubclass(option, Range):
            option_base.add_widget(self.create_range(option, name))
        elif issubclass(option, Toggle):
            option_base.add_widget(self.create_toggle(option, name))
        elif issubclass(option, TextChoice):
            option_base.add_widget(self.create_text_choice(option, name))
        elif issubclass(option, Choice):
            option_base.add_widget(self.create_choice(option, name))
        elif issubclass(option, FreeText):
            option_base.add_widget(self.create_free_text(option, name))

        if option_can_be_randomized(option):
            def randomize_option(instance: Widget, value: str):
                value = value == "down"
                if value:
                    self.options[name] = "random-" + str(self.options[name])
                else:
                    self.options[name] = self.options[name].replace("random-", "")
                    if self.options[name].isnumeric() or self.options[name] in ("True", "False"):
                        self.options[name] = eval(self.options[name])

                base_object = instance.parent.parent
                label_object = instance.parent
                for child in base_object.children:
                    if child is not label_object:
                        child.disabled = value
            default_random = option.default == "random"
            random_toggle = ToggleButton(MDButtonText("Random?"), size_hint_x=None, width=100, state="down" if default_random else "normal")
            random_toggle.bind(state=randomize_option)
            label_box.add_widget(random_toggle)
            if default_random:
                randomize_option(random_toggle, "down")

        return option_base

    def create_options_panel(self, world_button):
        self.option_layout.clear_widgets()
        self.options.clear()
        cls: typing.Type[World] = world_button.world_cls

        self.current_game = cls.game
        if not cls.web.options_page:
            self.current_game = "None"
            return
        elif isinstance(cls.web.options_page, str):
            self.current_game = "None"
            if validate_url(cls.web.options_page):
                webbrowser.open(cls.web.options_page)
            else:
                # attach onto archipelago.gg and see if we pass
                new_url = "https://archipelago.gg/" + cls.web.options_page
                if validate_url(new_url):
                    webbrowser.open(new_url)
                # else just fall through
        else:
            expansion_box = MDBoxLayout(orientation="vertical")
            group_names = ["Game Options", *(group.name for group in cls.web.option_groups)]
            groups = {name: [] for name in group_names}
            for name, option in cls.options_dataclass.type_hints.items():
                group = next((group.name for group in cls.web.option_groups if option in group.options), "Game Options")
                groups[group].append((name, option))
            for group, options in groups.items():
                group_content = MDExpansionPanelContent()
                group_header = MDExpansionPanelHeader(MDListItem(MDLabel(), MDListItemTrailingIcon(icon="chevron-right")))
                group_item = MDExpansionPanel()
                group_item.add_widget(group_header)
                group_item.add_widget(group_content)
                group_box = ScrollBox()
                group_box.layout.orientation = "vertical"
                group_box.layout.spacing = dp(3)
                group_box.scroll_type = ["bars"]
                for name, option in options:
                    if name and option is not Removed and option.visibility & Visibility.simple_ui:
                        group_box.layout.add_widget(self.create_option(option, name))
                group_item.box = group_box

                def disable_box(instance):
                    instance.box.disabled = True

                def enable_box(instance):
                    instance.box.disabled = False

                group_item.bind(on_close=disable_box)
                group_item.bind(on_open=enable_box)
                group_content.add_widget(group_box)
                expansion_box.add_widget(group_item)
            self.option_layout.add_widget(expansion_box)
        self.game_label.text = f"Game: {self.current_game}"

    def build(self):
        self.options = {}
        self.container = ContainerLayout()
        self.main_layout = MainLayout(cols=2)
        self.container.add_widget(self.main_layout)
        self.scrollbox = ScrollBox(size_hint_x=None, width=dp(150))
        self.scrollbox.layout.orientation = "vertical"
        for world, cls in sorted(AutoWorldRegister.world_types.items(), key=lambda x: x[0]):
            if world == "Archipelago":
                continue
            world_text = MDButtonText(text=world, size_hint_y=None, width=dp(150), pos_hint={"x": 0.03, "center_y": 0.5})
            world_text.text_size = (world_text.width, None)
            world_text.bind(width=lambda *x, text=world_text: text.setter('text_size')(text, (text.width, None)),
                            texture_size=lambda *x, text=world_text: text.setter("height")(text,
                                                                                           world_text.texture_size[1]))
            world_button = MDButton(world_text, size_hint_x=None, width=dp(150), theme_width="Custom")
            world_button.radius = (dp(5), dp(5), dp(5), dp(5))
            world_button.bind(on_release=self.create_options_panel)
            world_button.world_cls = cls
            self.scrollbox.layout.add_widget(world_button)
        self.main_panel = MainLayout(rows=2)
        self.player_options = MDBoxLayout(orientation="horizontal", height=dp(60))
        name_box = MDBoxLayout(orientation="vertical")
        button_box = MDBoxLayout(orientation="vertical")
        self.game_label = MDLabel(text="Game: None")
        button_box.add_widget(self.game_label)
        name_box.add_widget(MDLabel(text="Player Name"))
        self.name_input = MDTextField(multiline=False)
        name_box.add_widget(self.name_input)
        self.player_options.add_widget(name_box)
        export_button = MDButton(MDButtonText("Export Options"))
        export_button.bind(on_press=self.export_options)
        button_box.add_widget(export_button)
        self.player_options.add_widget(button_box)
        self.option_layout = MainLayout(cols=1)
        self.main_panel.add_widget(self.player_options)
        self.main_panel.add_widget(self.option_layout)
        self.main_layout.add_widget(self.scrollbox)
        self.main_layout.add_widget(self.main_panel)

        return self.container


def launch():
    YamlCreator().run()
