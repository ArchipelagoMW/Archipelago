from kvui import (App, ScrollBox, Button, MainLayout, ContainerLayout, dp, Widget, BoxLayout, TooltipLabel, ToolTip,
                  Label)
from kivy.graphics import Rectangle, Color
from kivy.uix.slider import Slider
from kivy.uix.dropdown import DropDown
from kivy.uix.checkbox import CheckBox
from kivy.uix.textinput import TextInput
from kivy.uix.togglebutton import ToggleButton
from kivy.metrics import sp
from textwrap import dedent
import Utils
import typing
import webbrowser
from urllib.parse import urlparse
from worlds.AutoWorld import AutoWorldRegister, World
from Options import (Option, Toggle, TextChoice, Choice, FreeText, NamedRange, Range, OptionSet, OptionList, OptionDict,
                     Removed, Visibility, VerifyKeys, PlandoTexts, PlandoConnections, ItemLinks)

try:
    from Utils import save_filename
except ImportError:
    import logging
    import subprocess
    def save_filename(title: str, filetypes: typing.Iterable[typing.Tuple[str, typing.Iterable[str]]],
                      suggest: str = "") \
            -> typing.Optional[str]:
        logging.info(f"Opening file save dialog for {title}.")

        def run(*args: str):
            return subprocess.run(args, capture_output=True, text=True).stdout.split("\n", 1)[0] or None

        if Utils.is_linux:
            # prefer native dialog
            from shutil import which
            kdialog = which("kdialog")
            if kdialog:
                k_filters = '|'.join((f'{text} (*{" *".join(ext)})' for (text, ext) in filetypes))
                return run(kdialog, f"--title={title}", "--getsavefilename", suggest or ".", k_filters)
            zenity = which("zenity")
            if zenity:
                z_filters = (f'--file-filter={text} ({", ".join(ext)}) | *{" *".join(ext)}' for (text, ext) in
                             filetypes)
                selection = (f"--filename={suggest}",) if suggest else ()
                return run(zenity, f"--title={title}", "--file-selection", "--save", *z_filters, *selection)

        # fall back to tk
        try:
            import tkinter
            import tkinter.filedialog
        except Exception as e:
            logging.error('Could not load tkinter, which is likely not installed. '
                          f'This attempt was made because open_filename was used for "{title}".')
            raise e
        else:
            try:
                root = tkinter.Tk()
            except tkinter.TclError:
                return None  # GUI not available. None is the same as a user clicking "cancel"
            root.withdraw()
            return tkinter.filedialog.asksaveasfilename(title=title,
                                                        filetypes=((t[0], ' '.join(t[1])) for t in filetypes),
                                                        initialfile=suggest or None)

def validate_url(x):
    try:
        result = urlparse(x)
        return all([result.scheme, result.netloc])
    except AttributeError:
        return False


def filter_tooltip(tooltip):
    return dedent(tooltip).replace("\n", "<br>").replace("&", "&amp;").replace("[", "&bl;").replace("]", "&br;")


def option_can_be_randomized(option: typing.Type[Option]):
    # most options can be randomized, so we should just check for those that cannot
    if any(issubclass(option, option_type) for option_type in (VerifyKeys, Removed, PlandoTexts,
                                                               PlandoConnections, ItemLinks)):
        return False
    elif issubclass(option, FreeText) and not issubclass(option, TextChoice):
        return False
    return True

def check_random(value: typing.Any):
    if not isinstance(value, str):
        return value # cannot be random if evaluated
    if value.startswith("random-"):
        return "random"
    return value

class YamlCreator(App):
    container: ContainerLayout
    main_layout: MainLayout
    scrollbox: ScrollBox
    main_panel: MainLayout
    player_options: MainLayout
    option_layout: MainLayout
    name_input: TextInput
    current_game: str
    options: typing.Dict[str, typing.Any]

    def export_options(self, _: Widget):
        if self.name_input.text and self.current_game:
            file_name = Utils.save_filename("Export Options File As...", [("YAML", ["*.yaml"])],
                                            Utils.get_file_safe_name(f"{self.name_input.text}.yaml"))
            options = {
                "name": self.name_input.text,
                "description": f"YAML generated by Archipelago {Utils.__version__}.",
                "game": self.current_game,
                self.current_game: {k: check_random(v) for k, v in self.options.items()}
            }
            with open(file_name, 'w') as f:
                f.write(Utils.dump(options, sort_keys=False))
                f.close()

    def create_range(self, option: typing.Type[Range], name: str):
        def update_text(slider, touch):
            slider.text.text = f"{slider.value:.0f}"
            self.options[name] = int(slider.value)
            return

        box = BoxLayout(spacing=15, orientation="horizontal")
        slider = Slider(min=option.range_start, max=option.range_end, value=option.default, step=1)
        number_label = Label(text=str(option.default))
        slider.text = number_label
        slider.bind(on_touch_move=update_text)
        box.add_widget(slider)
        box.slider = slider
        box.add_widget(number_label)
        self.options[name] = option.default
        return box

    def create_named_range(self, option: typing.Type[NamedRange], name: str):
        def set_to_custom(slider, touch):
            slider.dropdown.select("Custom")
            self.options[name] = slider.value

        def set_value(button):
            slider_box.slider.dropdown.select(button.text)
            self.options[name] = button.text.lower()
            slider_box.slider.value = option.special_range_names[button.text.lower()]
            slider_box.slider.text.text = f"{slider_box.slider.value:.0f}"

        def open(button):
            # for some reason this fixes an issue causing some to not open
            slider_box.slider.dropdown.open(button)

        box = BoxLayout(orientation="vertical", spacing=5)
        slider_box = self.create_range(option, name)
        slider_box.slider.bind(on_touch_move=set_to_custom)
        slider_box.slider.dropdown = DropDown()
        for choice in option.special_range_names:
            btn = Button(text=choice.title(), size_hint_y=None)
            btn.bind(on_release=set_value)
            slider_box.slider.dropdown.add_widget(btn)
        if option.default in option.special_range_names.values():
            default = list(option.special_range_names.keys())[list(option.special_range_names.values())
                                                              .index(option.default)]
        else:
            default = "Custom"
        main_button = Button(text=default.title())
        main_button.bind(on_release=open)
        slider_box.slider.dropdown.bind(on_select=lambda instance, x: setattr(main_button, 'text', x))
        box.add_widget(main_button)
        box.add_widget(slider_box)
        self.options[name] = option.default
        return box

    def create_free_text(self, option: typing.Union[typing.Type[FreeText], typing.Type[TextChoice]], name: str):
        text = TextInput(multiline=False, font_size=sp(11),
                         text=option.default if isinstance(option.default, str) else "")
        def set_value(instance):
            self.options[name] = instance.text

        text.bind(on_text_validate=set_value)
        return text

    def create_choice(self, option: typing.Type[Choice], name: str):
        def set_value(button):
            dropdown.select(button.text)
            self.options[name] = button.value

        def open(button):
            # for some reason this fixes an issue causing some to not open
            dropdown.open(button)

        dropdown = DropDown()
        for choice in option.name_lookup:
            btn = Button(text=option.get_option_name(choice), size_hint_y=None)
            btn.value = option.name_lookup[choice]
            btn.bind(on_release=set_value)
            dropdown.add_widget(btn)
        default_random = option.default == "random"
        default = option.default if not default_random else list(option.options.values())[0]
        main_button = Button(text=option.get_option_name(default))
        main_button.bind(on_release=open)
        self.options[name] = option.name_lookup[option.default] if not default_random else option.default
        dropdown.bind(on_select=lambda instance, x: setattr(main_button, 'text', x))
        return main_button

    def create_text_choice(self, option: typing.Type[TextChoice], name: str):
        choice_button = self.create_choice(option, name)
        text = self.create_free_text(option, name)
        box = BoxLayout(orientation="vertical")
        box.add_widget(choice_button)
        box.add_widget(text)

        def set_value(instance):
            setattr(choice_button, "text", "Custom")
            self.options[name] = instance.text

        text.bind(on_text_validate=set_value)
        return box

    def create_toggle(self, option: typing.Type[Toggle], name: str) -> Widget:
        def set_value(instance, value):
            self.options[name] = bool(value)
        checkbox = CheckBox(active=option.default)
        checkbox.bind(active=set_value)
        self.options[name]=bool(option.default)
        return checkbox


    def create_option(self, option: typing.Type[Option], name: str) -> Widget:
        option_base = BoxLayout(orientation="vertical", size_hint_y=None)
        with option_base.canvas:
            Color(0.2, 0.2, 0.2, 1)
            option_base.bg_rect = Rectangle(size=option_base.size, pos=option_base.pos)

        def redraw(self, args):
            self.bg_rect.size = self.size
            self.bg_rect.pos = self.pos

        option_base.bind(pos=redraw, size=redraw)

        tooltip = filter_tooltip(option.__doc__)
        option_label = TooltipLabel(text=f"[ref=0|{tooltip}]{getattr(option, 'display_name', name)}",
                                    size_hint_y=None)
        label_box = BoxLayout(orientation="horizontal")
        label_box.add_widget(option_label)

        option_base.add_widget(label_box)
        if issubclass(option, NamedRange):
            option_base.add_widget(self.create_named_range(option, name))
        elif issubclass(option, Range):
            option_base.add_widget(self.create_range(option, name))
        elif issubclass(option, Toggle):
            option_base.add_widget(self.create_toggle(option, name))
        elif issubclass(option, TextChoice):
            option_base.add_widget(self.create_text_choice(option, name))
        elif issubclass(option, Choice):
            option_base.add_widget(self.create_choice(option, name))
        elif issubclass(option, FreeText):
            option_base.add_widget(self.create_free_text(option, name))

        if option_can_be_randomized(option):
            def randomize_option(instance: Widget, value: str):
                value = value == "down"
                if value:
                    self.options[name] = "random-" + str(self.options[name])
                else:
                    self.options[name] = self.options[name].replace("random-", "")
                    if self.options[name].isnumeric() or self.options[name] in ("True", "False"):
                        self.options[name] = eval(self.options[name])

                def recursive_disable(inst: Widget, val: bool):
                    inst.disabled = val
                    for child in inst.children:
                        recursive_disable(child, val)

                base_object = instance.parent.parent
                label_object = instance.parent
                for child in base_object.children:
                    if child is not label_object:
                        recursive_disable(child, value)
            default_random = option.default == "random"
            random_toggle = ToggleButton(size_hint_x=None, width=100, text="Random?",
                                         state="down" if default_random else "normal")
            random_toggle.bind(state=randomize_option)
            label_box.add_widget(random_toggle)
            if default_random:
                randomize_option(random_toggle, "down")

        return option_base

    def create_options_panel(self, world_button):
        self.option_layout.clear_widgets()
        self.options.clear()
        cls: typing.Type[World] = world_button.world_cls
        self.current_game = cls.game
        if not cls.web.options_page:
            return
        elif isinstance(cls.web.options_page, str):
            if validate_url(cls.web.options_page):
                webbrowser.open(cls.web.options_page)
            else:
                # attach onto archipelago.gg and see if we pass
                new_url = "https://archipelago.gg/" + cls.web.options_page
                if validate_url(new_url):
                    webbrowser.open(new_url)
                # else just fall through
        else:
            new_scroll = ScrollBox()
            new_scroll.scroll_type = ["bars"]
            new_scroll.layout.orientation = "vertical"
            new_scroll.layout.spacing = dp(3)
            for name, option in cls.options_dataclass.type_hints.items():
                if option is not Removed and option.visibility & Visibility.simple_ui:
                    new_scroll.layout.add_widget(self.create_option(option, name))
            self.option_layout.add_widget(new_scroll)

    def build(self):
        self.options = {}
        self.container = ContainerLayout()
        self.main_layout = MainLayout(cols=2)
        self.container.add_widget(self.main_layout)
        self.scrollbox = ScrollBox(size_hint_x=None, width=dp(150))
        self.scrollbox.layout.orientation = "vertical"
        for world, cls in AutoWorldRegister.world_types.items():
            if world == "Archipelago":
                continue
            world_button = Button(text=world, size_hint_y=None)
            world_button.text_size = (dp(100), None)
            world_button.bind(on_release=self.create_options_panel)
            world_button.world_cls = cls
            self.scrollbox.layout.add_widget(world_button)
        self.main_panel = MainLayout(rows=2)
        self.player_options = BoxLayout(orientation="horizontal", size_hint_y=None, height=dp(60))
        name_box = BoxLayout(orientation="vertical")
        name_box.add_widget(Label(text="Player Name"))
        self.name_input = TextInput(multiline=False)
        name_box.add_widget(self.name_input)
        self.player_options.add_widget(name_box)
        export_button = Button(text="Export Options")
        export_button.bind(on_press=self.export_options)
        self.player_options.add_widget(export_button)
        self.option_layout = MainLayout(cols=1)
        self.main_panel.add_widget(self.player_options)
        self.main_panel.add_widget(self.option_layout)
        self.main_layout.add_widget(self.scrollbox)
        self.main_layout.add_widget(self.main_panel)

        return self.container


def launch():
    YamlCreator().run()
