from kvui import (MDApp, ScrollBox, MainLayout, ContainerLayout, dp, Widget, MDBoxLayout, TooltipLabel, ToolTip,
                  MDLabel, ToggleButton)
from kivy.animation import Animation
from kivy.graphics import Rectangle, Color
from kivy.uix.behaviors.button import ButtonBehavior
from kivymd.uix.behaviors import RotateBehavior
from kivymd.uix.anchorlayout import MDAnchorLayout
from kivymd.uix.expansionpanel import MDExpansionPanel, MDExpansionPanelContent, MDExpansionPanelHeader
from kivymd.uix.list import MDListItem, MDListItemTrailingIcon, MDListItemSupportingText
from kivymd.uix.slider import MDSlider, MDSliderHandle, MDSliderValueLabel
from kivymd.uix.menu import MDDropdownMenu
from kivymd.uix.button import MDButton, MDButtonText, MDIconButton
from kivymd.uix.textfield import MDTextField, MDTextFieldHintText
from kivymd.uix.dialog import MDDialog, MDDialogHeadlineText, MDDialogContentContainer, MDDialogSupportingText
from kivymd.uix.divider import MDDivider
from kivymd.uix.floatlayout import MDFloatLayout
from kivy.metrics import sp
from textwrap import dedent
from copy import deepcopy
import Utils
import typing
import webbrowser
from urllib.parse import urlparse
from worlds.AutoWorld import AutoWorldRegister, World
from Options import (Option, Toggle, TextChoice, Choice, FreeText, NamedRange, Range, OptionSet, OptionList, OptionDict,
                     Removed, Visibility, VerifyKeys, PlandoTexts, PlandoConnections, ItemLinks)

from .core import save_filename, FixedTooltipLabel


def validate_url(x):
    try:
        result = urlparse(x)
        return all([result.scheme, result.netloc])
    except AttributeError:
        return False


def filter_tooltip(tooltip):
    if tooltip is None:
        tooltip = "No tooltip available."
    return dedent(tooltip).replace("\n", "<br>").replace("&", "&amp;").replace("[", "&bl;").replace("]", "&br;")


def option_can_be_randomized(option: typing.Type[Option]):
    # most options can be randomized, so we should just check for those that cannot
    if any(issubclass(option, option_type) for option_type in (VerifyKeys, Removed, PlandoTexts,
                                                               PlandoConnections, ItemLinks)):
        return False
    elif issubclass(option, FreeText) and not issubclass(option, TextChoice):
        return False
    return True


def check_random(value: typing.Any):
    if not isinstance(value, str):
        return value  # cannot be random if evaluated
    if value.startswith("random-"):
        return "random"
    return value


class TrailingPressedIconButton(
    ButtonBehavior, RotateBehavior, MDListItemTrailingIcon
):
    pass


class YamlCreator(MDApp):
    container: ContainerLayout
    main_layout: MainLayout
    scrollbox: ScrollBox
    main_panel: MainLayout
    player_options: MainLayout
    option_layout: MainLayout
    name_input: MDTextField
    game_label: MDLabel
    current_game: str
    options: typing.Dict[str, typing.Any]

    def export_options(self, _: Widget):
        if self.name_input.text and self.current_game:
            file_name = save_filename("Export Options File As...", [("YAML", ["*.yaml"])],
                                      Utils.get_file_safe_name(f"{self.name_input.text}.yaml"))
            options = {
                "name": self.name_input.text,
                "description": f"YAML generated by Archipelago {Utils.__version__}.",
                "game": self.current_game,
                self.current_game: {k: check_random(v) for k, v in self.options.items()}
            }
            with open(file_name, 'w') as f:
                f.write(Utils.dump(options, sort_keys=False))
                f.close()

    def create_range(self, option: typing.Type[Range], name: str):
        def update_text(slider, touch):
            slider.text.text = f"{slider.value:.0f}"
            self.options[name] = int(slider.value)
            return

        box = MDBoxLayout(spacing=15, orientation="horizontal")
        slider = MDSlider(MDSliderHandle(), MDSliderValueLabel(), min=option.range_start, max=option.range_end,
                          value=option.default, step=1, step_point_size=0)
        number_label = MDLabel(text=str(option.default))
        slider.text = number_label
        slider.bind(on_touch_move=update_text)
        box.add_widget(slider)
        box.slider = slider
        box.add_widget(number_label)
        self.options[name] = option.default
        return box

    def create_named_range(self, option: typing.Type[NamedRange], name: str):
        def set_to_custom(slider, touch):
            if (not self.options[name] == slider.value) and (not self.options[name] in option.special_range_names or
                                                             slider.value != option.special_range_names[
                                                                 self.options[name]]):
                # we should validate the touch here,
                # but this is much cheaper
                self.options[name] = slider.value
                set_button_text(main_button, "Custom")

        def set_button_text(button: MDButton, text: str):
            for child in button.children:
                if isinstance(child, MDButtonText):
                    child.text = text

        def set_value(text):
            set_button_text(main_button, text)
            self.options[name] = text.lower()
            slider_box.slider.value = option.special_range_names[text.lower()]
            slider_box.slider.text.text = f"{slider_box.slider.value:.0f}"
            slider_box.slider.dropdown.dismiss()

        def open(button):
            # for some reason this fixes an issue causing some to not open
            slider_box.slider.dropdown.open()

        box = MDBoxLayout(orientation="vertical", spacing=5)
        slider_box = self.create_range(option, name)
        slider_box.slider.bind(on_touch_move=set_to_custom)
        items = [
            {
                "text": choice.title(),
                "on_release": lambda text=choice.title(): set_value(text)
            }
            for choice in option.special_range_names
        ]
        slider_box.slider.dropdown = MDDropdownMenu(caller=slider_box.slider, items=items)
        if option.default in option.special_range_names.values():
            default = list(option.special_range_names.keys())[list(option.special_range_names.values())
            .index(option.default)]
        else:
            default = "Custom"
        main_button = MDButton(MDButtonText(text=default.title()))
        main_button.bind(on_release=open)
        box.add_widget(main_button)
        box.add_widget(slider_box)
        self.options[name] = option.default
        return box

    def create_free_text(self, option: typing.Union[typing.Type[FreeText], typing.Type[TextChoice]], name: str):
        text = MDTextField(multiline=False, font_size=sp(11),
                           text=option.default if isinstance(option.default, str) else "")

        def set_value(instance):
            self.options[name] = instance.text

        text.bind(on_text_validate=set_value)
        return text

    def create_choice(self, option: typing.Type[Choice], name: str):
        def set_button_text(button: MDButton, text: str):
            for child in button.children:
                if isinstance(child, MDButtonText):
                    child.text = text

        def set_value(text, value):
            set_button_text(main_button, text)
            self.options[name] = value
            dropdown.dismiss()

        def open(button):
            # for some reason this fixes an issue causing some to not open
            dropdown.open()

        default_random = option.default == "random"
        default = option.default if not default_random else list(option.options.values())[0]
        main_button = MDButton(MDButtonText(text=option.get_option_name(default)))
        main_button.bind(on_release=open)

        items = [
            {
                "text": option.get_option_name(choice),
                "on_release": lambda val=choice: set_value(option.get_option_name(val), option.name_lookup[val])
            }
            for choice in option.name_lookup
        ]
        dropdown = MDDropdownMenu(caller=main_button, items=items)
        self.options[name] = option.name_lookup[option.default] if not default_random else option.default
        dropdown.bind(on_select=lambda instance, x: setattr(main_button, '_text', x))
        return main_button

    def create_text_choice(self, option: typing.Type[TextChoice], name: str):
        def set_button_text(button: MDButton, text: str):
            for child in button.children:
                if isinstance(child, MDButtonText):
                    child.text = text

        choice_button = self.create_choice(option, name)
        text = self.create_free_text(option, name)
        box = MDBoxLayout(orientation="vertical")
        box.add_widget(choice_button)
        box.add_widget(text)

        def set_value(instance):
            set_button_text(choice_button, "Custom")
            self.options[name] = instance.text

        text.bind(on_text_validate=set_value)
        return box

    def create_toggle(self, option: typing.Type[Toggle], name: str) -> Widget:
        def set_value(instance: ToggleButton):
            if instance.icon == "checkbox-outline":
                instance.icon = "checkbox-blank-outline"
            else:
                instance.icon = "checkbox-outline"
            self.options[name] = bool(not self.options[name])

        def_icon = "checkbox-outline" if option.default else "checkbox-blank-outline"
        checkbox = MDIconButton(icon=def_icon)
        checkbox.bind(on_release=set_value)
        self.options[name] = bool(option.default)
        return checkbox

    def create_popup(self, option: typing.Type[OptionList] | typing.Type[OptionSet], name: str,
                     world: typing.Type[World]):
        # Despite taking verify keys, we're only supporting Set/List
        # Dict may be feasible in the future, but it needs additional typing work
        def remove_item(button: MDIconButton):
            list_item = button.parent
            scrollbox.layout.remove_widget(list_item)

        def add_generic_item(key: str = "New Item"):
            item = MDListItem(theme_bg_color="Custom", md_bg_color=self.theme_cls.surfaceContainerLowColor)
            text = MDTextField(text=key, id="value", pos_hint={"center_x": 0.5, "center_y": 0.5}, size_hint_x=None,
                               width=dp(400))
            item.text = text
            item.ids.text_container.add_widget(text)
            item.add_widget(MDIconButton(icon="minus", on_release=remove_item, pos_hint={"center_x": 0.95,
                                                                                         "center_y": 0.5}))
            scrollbox.layout.add_widget(item)

        def add_set_item(key: str):
            text = MDListItemSupportingText(text=key, id="value")
            item = MDListItem(text, MDIconButton(icon="minus", on_release=remove_item))
            item.text = text
            scrollbox.layout.add_widget(item)

        valid_keys = deepcopy(option.valid_keys)
        if option.verify_item_name:
            valid_keys += list(world.item_name_to_id.keys())
        if option.verify_location_name:
            valid_keys += list(world.location_name_to_id.keys())

        def apply_changes(button):
            if valid_keys:
                if name not in self.options:
                    self.options[name] = []
                self.options[name].clear()
                for list_item in scrollbox.layout.children:
                    self.options[name].append(getattr(list_item.text, "text"))
            else:
                if name not in self.options:
                    self.options[name] = set()
                self.options[name].clear()
                for list_item in scrollbox.layout.children:
                    if isinstance(list_item.text, MDTextField):
                        text = getattr(list_item.text, "text")
                    else:
                        text = getattr(list_item.text, "_text")
                    self.options[name].add()
            dialog.dismiss()

        content = MDDialogContentContainer(MDDivider(), orientation="vertical")
        add_button = MDIconButton(icon="plus", pos_hint={"center_x": 1, "center_y": 0.5})
        content.add_widget(add_button)
        scrollbox = ScrollBox(size_hint_y=None)
        scrollbox.layout.md_bg_color = self.theme_cls.surfaceContainerLowColor
        scrollbox.layout.theme_bg_color = "Custom"
        scrollbox.layout.spacing = dp(5)
        scrollbox.layout.padding = [0, dp(5), 0, 0]
        scrollbox.layout.orientation = "vertical"
        scrollbox.do_scroll_x = False
        content.add_widget(scrollbox)
        if valid_keys:
            def add_item(text):
                add_set_item(text)
                dropdown.dismiss()

            menu_items = [
                {
                    "text": choice.title(),
                    "on_release": lambda text=choice.title(): add_item(text)
                }
                for choice in valid_keys
            ]
            dropdown = MDDropdownMenu(caller=add_button, items=menu_items)
            add_button.bind(on_release=lambda x: dropdown.open())
            for item in sorted(option.default):
                add_set_item(item)
        else:
            add_button.bind(on_release=lambda x: add_generic_item())
            for item in sorted(option.default):
                add_generic_item(item)

        content.add_widget(MDButton(MDButtonText(text="Save"), on_release=apply_changes))

        dialog = MDDialog(
            # Headline
            MDDialogHeadlineText(text=getattr(option, 'display_name', name)),
            # Text
            MDDialogSupportingText(text="Add or Remove Entries"),
            # Content
            content

        )
        dialog.open()

    def create_option_set_list(self, option: typing.Type[OptionList] | typing.Type[OptionSet], name: str,
                               world: typing.Type[World]):
        main_button = MDButton(MDButtonText(text="Edit"), on_release=lambda x: self.create_popup(option, name, world))
        return main_button

    def create_option(self, option: typing.Type[Option], name: str, world: typing.Type[World]) -> Widget:
        option_base = MDBoxLayout(orientation="vertical", size_hint_y=None)

        tooltip = filter_tooltip(option.__doc__)
        option_label = FixedTooltipLabel(text=f"[ref=0|{tooltip}]{getattr(option, 'display_name', name)}")
        label_box = MDBoxLayout(orientation="horizontal")
        label_anchor = MDAnchorLayout(anchor_x="right", anchor_y="center")
        label_anchor.add_widget(option_label)
        label_box.add_widget(label_anchor)

        option_base.add_widget(label_box)
        if issubclass(option, NamedRange):
            option_base.add_widget(self.create_named_range(option, name))
        elif issubclass(option, Range):
            option_base.add_widget(self.create_range(option, name))
        elif issubclass(option, Toggle):
            option_base.add_widget(self.create_toggle(option, name))
        elif issubclass(option, TextChoice):
            option_base.add_widget(self.create_text_choice(option, name))
        elif issubclass(option, Choice):
            option_base.add_widget(self.create_choice(option, name))
        elif issubclass(option, FreeText):
            option_base.add_widget(self.create_free_text(option, name))
        elif issubclass(option, OptionList):
            option_base.add_widget(self.create_option_set_list(option, name))
        elif issubclass(option, OptionSet):
            option_base.add_widget(self.create_option_set_list(option, name, world))
        else:
            option_base.add_widget(MDLabel(text="This option isn't supported by the yaml maker.\n"
                                                "Please edit your yaml manually to set this option."))

        if option_can_be_randomized(option):
            def randomize_option(instance: Widget, value: str):
                value = value == "down"
                if value:
                    self.options[name] = "random-" + str(self.options[name])
                else:
                    self.options[name] = self.options[name].replace("random-", "")
                    if self.options[name].isnumeric() or self.options[name] in ("True", "False"):
                        self.options[name] = eval(self.options[name])

                base_object = instance.parent.parent
                label_object = instance.parent
                for child in base_object.children:
                    if child is not label_object:
                        child.disabled = value

            default_random = option.default == "random"
            random_toggle = ToggleButton(MDButtonText(text="Random?"), size_hint_x=None, width=dp(100),
                                         state="down" if default_random else "normal")
            random_toggle.bind(state=randomize_option)
            label_box.add_widget(random_toggle)
            if default_random:
                randomize_option(random_toggle, "down")

        return option_base

    def create_options_panel(self, world_button):
        self.option_layout.clear_widgets()
        self.options.clear()
        cls: typing.Type[World] = world_button.world_cls

        self.current_game = cls.game
        if not cls.web.options_page:
            self.current_game = "None"
            return
        elif isinstance(cls.web.options_page, str):
            self.current_game = "None"
            if validate_url(cls.web.options_page):
                webbrowser.open(cls.web.options_page)
            else:
                # attach onto archipelago.gg and see if we pass
                new_url = "https://archipelago.gg/" + cls.web.options_page
                if validate_url(new_url):
                    webbrowser.open(new_url)
                # else just fall through
        else:
            expansion_box = ScrollBox()
            expansion_box.layout.orientation = "vertical"
            expansion_box.layout.spacing = dp(3)
            expansion_box.scroll_type = ["bars"]
            expansion_box.do_scroll_x = False
            group_names = ["Game Options", *(group.name for group in cls.web.option_groups)]
            groups = {name: [] for name in group_names}
            for name, option in cls.options_dataclass.type_hints.items():
                group = next((group.name for group in cls.web.option_groups if option in group.options), "Game Options")
                groups[group].append((name, option))
            for group, options in groups.items():
                group_item = MDExpansionPanel(size_hint_y=None)
                group_header = MDExpansionPanelHeader(MDListItem(MDListItemSupportingText(text=group),
                                                                 TrailingPressedIconButton(icon="chevron-right",
                                                                                           on_release=lambda x,
                                                                                                             item=group_item:
                                                                                           self.tap_expansion_chevron(
                                                                                               item, x)),
                                                                 md_bg_color=self.theme_cls.surfaceContainerLowestColor,
                                                                 theme_bg_color="Custom",
                                                                 on_release=lambda x, item=group_item:
                                                                 self.tap_expansion_chevron(item, x)))
                group_content = MDExpansionPanelContent(orientation="vertical", theme_bg_color="Custom",
                                                        md_bg_color=self.theme_cls.surfaceContainerLowestColor,
                                                        padding=[dp(12), dp(100), dp(12), 0],
                                                        spacing=dp(3))
                group_item.add_widget(group_header)
                group_item.add_widget(group_content)
                group_box = ScrollBox()
                group_box.layout.orientation = "vertical"
                group_box.layout.spacing = dp(3)
                for name, option in options:
                    if name and option is not Removed and option.visibility & Visibility.simple_ui:
                        group_content.add_widget(self.create_option(option, name, cls))
                expansion_box.layout.add_widget(group_item)
            self.option_layout.add_widget(expansion_box)
        self.game_label.text = f"Game: {self.current_game}"

    def tap_expansion_chevron(
            self, panel: MDExpansionPanel, chevron: TrailingPressedIconButton
    ):
        Animation(
            padding=[0, dp(12), 0, dp(12)]
            if not panel.is_open
            else [0, 0, 0, 0],
            d=0.2,
        ).start(panel)
        panel.open() if not panel.is_open else panel.close()
        panel.set_chevron_down(
            chevron
        ) if not panel.is_open else panel.set_chevron_up(chevron)

    def build(self):
        from kvui import KivyJSONtoTextParser
        text_colors = KivyJSONtoTextParser.TextColors()
        self.theme_cls.theme_style = getattr(text_colors, "theme_style", "Dark")
        self.theme_cls.primary_palette = getattr(text_colors, "primary_palette", "Green")
        self.options = {}
        self.container = ContainerLayout()
        self.container.md_bg_color = self.theme_cls.backgroundColor
        self.main_layout = MainLayout(cols=2)
        self.container.add_widget(self.main_layout)
        self.scrollbox = ScrollBox(size_hint_x=None, width=dp(150))
        self.scrollbox.do_scroll_x = False
        self.scrollbox.layout.orientation = "vertical"
        for world, cls in sorted(AutoWorldRegister.world_types.items(), key=lambda x: x[0]):
            if world == "Archipelago":
                continue
            world_text = MDButtonText(text=world, size_hint_y=None, width=dp(150),
                                      pos_hint={"x": 0.03, "center_y": 0.5})
            world_text.text_size = (world_text.width, None)
            world_text.bind(width=lambda *x, text=world_text: text.setter('text_size')(text, (text.width, None)),
                            texture_size=lambda *x, text=world_text: text.setter("height")(text,
                                                                                           world_text.texture_size[1]))
            world_button = MDButton(world_text, size_hint_x=None, width=dp(150), theme_width="Custom")
            world_button.radius = (dp(5), dp(5), dp(5), dp(5))
            world_button.bind(on_release=self.create_options_panel)
            world_button.world_cls = cls
            self.scrollbox.layout.add_widget(world_button)
        self.main_panel = MainLayout(rows=2)
        self.player_options = MDBoxLayout(orientation="horizontal", height=dp(60), size_hint_y=None, spacing=dp(5),
                                          padding=[0, dp(10), 0, 0])
        button_box = MDBoxLayout(orientation="vertical", spacing=dp(2))
        self.game_label = MDLabel(text="Game: None", pos_hint={"center_x": 0.5, "center_y": 0.5})
        button_box.add_widget(self.game_label)
        self.name_input = MDTextField(MDTextFieldHintText(text="Player Name"), multiline=False)
        self.player_options.add_widget(self.name_input)
        export_button = MDButton(MDButtonText(text="Export Options"), pos_hint={"center_x": 0.5, "center_y": 0.5})
        export_button.bind(on_press=self.export_options)
        button_box.add_widget(export_button)
        self.player_options.add_widget(button_box)
        self.option_layout = MainLayout(cols=1)
        self.main_panel.add_widget(self.player_options)
        self.main_panel.add_widget(self.option_layout)
        self.main_layout.add_widget(self.scrollbox)
        self.main_layout.add_widget(self.main_panel)

        return self.container


def launch():
    YamlCreator().run()
