# APWorld for DOOM II
#
# This file is automatically generated by ap_gen_tool version 2.0.
# For more information: https://github.com/ArchipelagoDoom/ap_gen_tool

import typing

import BaseClasses as AP  # noqa: N814
from worlds._id1common import id1CommonWorld
from worlds.AutoWorld import WebWorld

from .options import DOOM2OptionGroups, DOOM2Options

game_name = "DOOM II"


class DOOM2Location(AP.Location):
    game: str = game_name


class DOOM2Item(AP.Item):
    game: str = game_name


class DOOM2Web(WebWorld):
    option_groups = DOOM2OptionGroups
    rich_text_options_doc = True
    bug_report_page = "https://github.com/ArchipelagoDoom/APDoom/issues"
    theme = "dirt"
    tutorials = [AP.Tutorial(
        "Multiworld Setup Guide",
        f"A guide to setting up the {game_name} randomizer connected to an Archipelago Multiworld.",
        "English",
        "setup_en.md",
        "setup/en",
        ["Daivuk", "Kaito Sinclaire"]
    )]


class DOOM2World(id1CommonWorld, import_data=(__name__, "doom2.data.json")):
    """
    DOOM II: Hell on Earth is a first-person shooter released by id Software in 1994.
    The sequel to DOOM (1993), it introduces the Super Shotgun, and has larger levels and
    a significantly larger, more balanced monster bestiary.
    """
    game = game_name
    options_dataclass = DOOM2Options
    options: DOOM2Options  # type: ignore
    web = DOOM2Web()
    required_client_version = (0, 6, 3)  # APDoom version 2.0.0

    extra_connection_requirements = {
        "deathlogic": lambda self: self.options.allow_death_logic.value == 1,
        "trick_basic": lambda self: self.options.trick_difficulty.value >= 1,
        "trick_pro": lambda self: self.options.trick_difficulty.value >= 2,
        "trick_extreme": lambda self: self.options.trick_difficulty.value >= 3,
    }

    def create_item(self, name: str) -> DOOM2Item:
        item_id = self.item_name_to_id[name]
        item_data = self.item_table[item_id]
        classification = item_data.classification

        ######## Custom code for world option 'Invis as Trap' begins here ########
        invis_trap = self.options.partial_invisibility_as_trap
        if invis_trap.value and item_data.doom_type == invis_trap.doom_type:
            classification = AP.ItemClassification.trap
        ######## Custom code for world option 'Invis as Trap' ends here ########

        return DOOM2Item(name, classification, item_id, self.player)

    def generate_early(self) -> None:
        self.init_episodes()

        ######## Custom code for this world begins here ########
        # If soloing MAP01-MAP11, mark an earlier level as early to give generation a clue on how to proceed
        if self.solo_episode(1):
            early_level = self.random.choice(["Underhalls (MAP02)", "The Gantlet (MAP03)",
                                              "The Waste Tunnels (MAP05)", "The Crusher (MAP06)"])
            self.multiworld.early_items[self.player][early_level] = 1

        # If soloing MAP21-MAP30, we need to mark a weapon as early to help generation succeed
        elif self.solo_episode(3):
            early_weapon = self.random.choice(["Super Shotgun", "Plasma Gun"])
            self.multiworld.early_items[self.player][early_weapon] = 1
        ######## Custom code for this world ends here ########

        ######## Custom code for world option 'Custom Ammo Capacity' begins here ########
        if (
            self.options.max_ammo_bullets.value < self.options.max_ammo_bullets.default
            or self.options.max_ammo_shells.value < self.options.max_ammo_shells.default
            or self.options.max_ammo_energy_cells.value < self.options.max_ammo_energy_cells.default
            or self.options.max_ammo_rockets.value < self.options.max_ammo_rockets.default
        ):
            self.warning("Some starting ammo capacity options are set below their default values.\n"
                         "This may make games significantly harder than intended; you have been warned.")
        ######## Custom code for world option 'Custom Ammo Capacity' ends here ########

    def create_regions(self) -> None:
        self.construct_regions()
        self.make_regions(location_type=DOOM2Location)

    def set_rules(self) -> None:
        self.make_rules()

    def create_items(self) -> None:
        self.place_level_complete_items(item_type=DOOM2Item)

        itempool = self.construct_base_item_pool()
        location_count = len(self.multiworld.get_unfilled_locations(self.player))
        def pop_from_pool(name: str) -> str | None:
            return itempool.pop(itempool.index(name)) if name in itempool else None

        # Give starting levels immediately
        map_items = [pop_from_pool(map_name) for map_name in self.starting_levels]
        [self.multiworld.push_precollected(self.create_item(n)) for n in map_items if n is not None]

        ######## Custom code for world option 'Start with Maps' begins here ########
        map_opt = self.options.start_with_computer_area_maps
        if map_opt.value:
            map_items = [pop_from_pool(i.name) for i in self.matching_items(doom_type=map_opt.doom_type).values()]
            [self.multiworld.push_precollected(self.create_item(n)) for n in map_items if n is not None]
        ######## Custom code for world option 'Start with Maps' ends here ########

        ######## Custom code for world option 'Capacity Upgrades' begins here ########
        split_opt = self.options.split_backpack
        split_items = list(self.matching_items(doom_type=split_opt.split_doom_types).values())
        combined_items = list(self.matching_items(doom_type=split_opt.doom_type).values())

        # Remove stray capacity upgrades of all types from the pool
        item_names = [i.name for i in split_items] + [i.name for i in combined_items]
        itempool = [n for n in itempool if n not in item_names]

        # Insert requested types and count of capacity upgrades
        if split_opt.value:
            itempool += [i.name for i in split_items for _ in range(self.options.backpack_count.value)]
        else:
            itempool += [i.name for i in combined_items for _ in range(self.options.backpack_count.value)]
        ######## Custom code for world option 'Capacity Upgrades' ends here ########

        # Fill remainder with filler, and submit
        self.fill_item_pool(itempool, location_count)
        self.multiworld.itempool.extend(self.create_item(item) for item in itempool)

    def fill_slot_data(self) -> dict[str, typing.Any]:
        slot_data = super().fill_slot_data()

        ######## Custom code for world option 'Custom Ammo Capacity' begins here ########
        slot_data["ammo_start"] = [
            self.options.max_ammo_bullets.value,
            self.options.max_ammo_shells.value,
            self.options.max_ammo_energy_cells.value,
            self.options.max_ammo_rockets.value,
        ]
        slot_data["ammo_add"] = [
            self.options.added_ammo_bullets.value,
            self.options.added_ammo_shells.value,
            self.options.added_ammo_energy_cells.value,
            self.options.added_ammo_rockets.value,
        ]
        ######## Custom code for world option 'Custom Ammo Capacity' ends here ########

        return slot_data

